"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const typescript_estree_1 = require("@typescript-eslint/typescript-estree");
exports.default = {
  meta: utils_1.getRuleMetaData(
    "no-access-state-after-set",
    "disallows access of React state variables after they have been set in a useEffect function body"
  ),
  create: (context) => {
    const seenFunctions = new Set();
    return {
      "ClassDeclaration :matches(CallExpression[callee.property.name='setState'], CallExpression[callee.name='setState'])": (
        node
      ) => {
        const modifiedState = new Set();
        const addModifiedState = (state, modifiedState) => {
          state.properties.forEach((property) => {
            if (property.type === "SpreadElement") {
              return;
            }
            const { key } = property;
            if (key.type === "Literal") {
              modifiedState.add(key.value);
            } else if (key.type === "Identifier") {
              modifiedState.add(key.name);
            }
          });
        };
        const [stateArg] = node.arguments;
        if (stateArg.type === "ObjectExpression") {
          addModifiedState(stateArg, modifiedState);
        } else if (
          stateArg.type === "FunctionExpression" ||
          stateArg.type === "ArrowFunctionExpression"
        ) {
          typescript_estree_1.simpleTraverse(stateArg.body, {
            enter: (child, parent) => {
              if (
                child.type === "ObjectExpression" &&
                (parent === undefined || parent.type === "ReturnStatement")
              ) {
                addModifiedState(child, modifiedState);
              }
            },
          });
        }
        const ancestors = context.getAncestors().reverse();
        const blockAncestors = ancestors
          .slice(
            0,
            ancestors.findIndex(
              (ancestor) => ancestor.type === "ClassDeclaration"
            )
          )
          .filter((ancestor) => ancestor.type === "BlockStatement");
        let shouldContinue = true;
        blockAncestors.forEach((block) => {
          if (shouldContinue) {
            const { body } = block;
            const setStateIndex = body.findIndex((bodyItem) =>
              ancestors.includes(bodyItem)
            );
            const postSetStateBody = body.slice(setStateIndex + 1);
            postSetStateBody.forEach((bodyItem) => {
              typescript_estree_1.simpleTraverse(bodyItem, {
                enter: (child, parent) => {
                  if (
                    child.type === "Identifier" &&
                    (parent === null || parent === void 0
                      ? void 0
                      : parent.type) === "MemberExpression" &&
                    modifiedState.has(child.name)
                  ) {
                    let parentName = undefined;
                    if (parent.object.type === "MemberExpression") {
                      const parentProperty = parent.object.property;
                      parentName = parentProperty.name;
                    } else if (parent.object.type === "Identifier") {
                      parentName = parent.object.name;
                    }
                    if (parentName === "state") {
                      context.report({
                        node: parent,
                        message:
                          "state fields modified by a setState call should not be accessed afterwards in the same block",
                      });
                    }
                  }
                },
              });
            });
            if (
              postSetStateBody.some(
                (statement) => statement.type === "ReturnStatement"
              )
            ) {
              shouldContinue = false;
            }
          }
        });
      },
      ":matches(Program, ExportDefaultDeclaration, ExportNamedDeclaration) > :matches(FunctionDeclaration, FunctionExpression, ArrowFunctionExpression) ReturnStatement :matches(JSXElement, JSXFragment)": () => {
        const func = context
          .getAncestors()
          .find(
            (ancestor) =>
              ancestor.type === "FunctionDeclaration" ||
              ancestor.type === "FunctionExpression" ||
              ancestor.type === "ArrowFunctionExpression"
          );
        if (seenFunctions.has(func)) {
          return;
        }
        seenFunctions.add(func);
        const block = func.body;
        if (block.type !== "BlockStatement") {
          return;
        }
        const { body } = block;
        const stateSetters = new Set();
        const stateDict = {};
        const useStateArrayLength = 2;
        body.forEach((statement) => {
          if (statement.type === "VariableDeclaration") {
            statement.declarations.forEach((declaration) => {
              var _a, _b, _c;
              if (
                ((_a = declaration.init) === null || _a === void 0
                  ? void 0
                  : _a.type) === "CallExpression" &&
                declaration.init.callee.type === "Identifier" &&
                declaration.init.callee.name === "useState" &&
                declaration.id.type === "ArrayPattern" &&
                declaration.id.elements.length === useStateArrayLength &&
                ((_b = declaration.id.elements[0]) === null || _b === void 0
                  ? void 0
                  : _b.type) === "Identifier" &&
                ((_c = declaration.id.elements[1]) === null || _c === void 0
                  ? void 0
                  : _c.type) === "Identifier"
              ) {
                const fieldName = declaration.id.elements[0].name;
                const setterName = declaration.id.elements[1].name;
                stateSetters.add(setterName);
                stateDict[setterName] = fieldName;
              }
            });
          }
        });
        const functionTraverse = (child, parent) => {
          var _a, _b, _c;
          if (
            child.type === "Identifier" &&
            stateSetters.has(child.name) &&
            parent !== undefined &&
            parent.type !== "ArrowFunctionExpression"
          ) {
            const modifiedField = stateDict[child.name];
            const ancestors = [];
            let next = parent;
            let prev = child;
            while (next.parent !== undefined && next.parent !== func) {
              prev = next;
              next = next.parent;
              ancestors.push(prev);
            }
            if (next.type !== "BlockStatement") {
              return;
            }
            const blockAncestors = ancestors.filter(
              (ancestor) => ancestor.type === "BlockStatement"
            );
            if (blockAncestors.length >= 2) {
              const lastInternalBlock =
                blockAncestors[blockAncestors.length - 2];
              if (
                ((_a = lastInternalBlock.parent) === null || _a === void 0
                  ? void 0
                  : _a.type) === "FunctionDeclaration" ||
                (((_b = lastInternalBlock.parent) === null || _b === void 0
                  ? void 0
                  : _b.type) === "ArrowFunctionExpression" &&
                  ((_c = lastInternalBlock.parent.parent) === null ||
                  _c === void 0
                    ? void 0
                    : _c.type) === "VariableDeclarator")
              ) {
                blockAncestors.pop();
              }
            }
            let shouldContinue = true;
            blockAncestors.forEach((block) => {
              if (shouldContinue) {
                const { body } = block;
                const useStateIndex = body.findIndex((statement) =>
                  ancestors.includes(statement)
                );
                const postUseState = body.slice(useStateIndex + 1);
                postUseState.forEach((statement) =>
                  typescript_estree_1.simpleTraverse(statement, {
                    enter: (postChild) => {
                      var _a;
                      if (
                        postChild.type === "Identifier" &&
                        postChild.name === modifiedField &&
                        (((_a = postChild.parent) === null || _a === void 0
                          ? void 0
                          : _a.type) !== "MemberExpression" ||
                          postChild.parent.object === postChild)
                      ) {
                        context.report({
                          node: postChild,
                          message:
                            "state fields modified by a useState setter call should not be accessed afterwards in the same block",
                        });
                      }
                    },
                  })
                );
                if (
                  postUseState.some(
                    (statement) => statement.type === "ReturnStatement"
                  )
                ) {
                  shouldContinue = false;
                }
              }
            });
          }
        };
        body.forEach((statement) => {
          if (statement.type === "FunctionDeclaration") {
            typescript_estree_1.simpleTraverse(statement.body, {
              enter: functionTraverse,
            });
          } else if (
            statement.type === "ExpressionStatement" &&
            statement.expression.type === "CallExpression" &&
            statement.expression.callee.type === "Identifier" &&
            statement.expression.callee.name === "useEffect"
          ) {
            typescript_estree_1.simpleTraverse(
              statement.expression.arguments[0],
              {
                enter: functionTraverse,
              }
            );
          } else if (statement.type === "VariableDeclaration") {
            statement.declarations.forEach((declaration) => {
              var _a, _b;
              if (
                ((_a = declaration.init) === null || _a === void 0
                  ? void 0
                  : _a.type) === "FunctionExpression" ||
                ((_b = declaration.init) === null || _b === void 0
                  ? void 0
                  : _b.type) === "ArrowFunctionExpression"
              ) {
                typescript_estree_1.simpleTraverse(declaration.init.body, {
                  enter: functionTraverse,
                });
              }
            });
          }
        });
      },
    };
  },
};
