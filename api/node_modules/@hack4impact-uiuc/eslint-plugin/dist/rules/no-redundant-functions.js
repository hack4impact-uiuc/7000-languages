"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
exports.default = {
  meta: utils_1.getRuleMetaData(
    "no-redundant-functions",
    "forbids redundant functions that simply pass their arguments directly to another function in the same order"
  ),
  create: (context) => {
    const sourceCode = context.getSourceCode();
    const isInsideHook = () =>
      context
        .getAncestors()
        .some(
          (ancestor) =>
            ancestor.type === "CallExpression" &&
            ancestor.callee.type === "Identifier" &&
            ancestor.callee.name.startsWith("use")
        );
    const isFunctionRedundant = (caller, params) => {
      const paramsString = params
        .map((param) => sourceCode.getText(param).replace(/\s/g, ""))
        .join(",");
      const argumentsString = caller.arguments
        .map((argument) => sourceCode.getText(argument).replace(/\s/g, ""))
        .join(",");
      return paramsString === argumentsString;
    };
    return {
      ":matches(FunctionDeclaration, FunctionExpression)": (node) => {
        var _a;
        if (isInsideHook()) {
          return;
        }
        const { body, params } = node;
        const blockBody = body.body;
        const [statement] = blockBody;
        if (
          blockBody.length === 1 &&
          (statement.type === "ExpressionStatement" ||
            statement.type === "ReturnStatement")
        ) {
          let caller = null;
          if (
            statement.type === "ExpressionStatement" &&
            statement.expression.type === "CallExpression"
          ) {
            caller = statement.expression;
          } else if (
            statement.type === "ReturnStatement" &&
            ((_a = statement.argument) === null || _a === void 0
              ? void 0
              : _a.type) === "CallExpression"
          ) {
            caller = statement.argument;
          }
          if (caller !== null && isFunctionRedundant(caller, params)) {
            context.report({
              node,
              message: `function is redundant, use called method in function body instead`,
            });
          }
        }
      },
      ArrowFunctionExpression: (node) => {
        var _a;
        if (isInsideHook()) {
          return;
        }
        const { params, body } = node;
        let caller = null;
        if (
          body.type === "CallExpression" &&
          body.callee.type !== "MemberExpression"
        ) {
          caller = body;
        } else if (body.type === "BlockStatement") {
          const blockBody = body.body;
          if (blockBody.length === 1) {
            const [statement] = blockBody;
            if (
              statement.type === "ExpressionStatement" &&
              statement.expression.type === "CallExpression"
            ) {
              caller = statement.expression;
            } else if (
              statement.type === "ReturnStatement" &&
              ((_a = statement.argument) === null || _a === void 0
                ? void 0
                : _a.type) === "CallExpression"
            ) {
              caller = statement.argument;
            }
          }
        }
        if (caller !== null && isFunctionRedundant(caller, params)) {
          context.report({
            node,
            message: `function is redundant, use called method in function body instead`,
          });
        }
      },
    };
  },
};
